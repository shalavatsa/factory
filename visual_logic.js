/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.10.0
 * Fri, 04 Jul 2025 12:36:51 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        // css renderer prevents interacting with canvas, in that case we assign events on container
        const elem = appInstance.cssRenderer ? appInstance.container : appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function isObjectAmongObjects(objNameToCheck, objUUIDToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        // COMPAT: <4.10, when calling with 2 arguments
        if (Array.isArray(objUUIDToCheck)) {
            objNames = objUUIDToCheck;
            objUUIDToCheck = objNameToCheck;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            const objName = objNames[i];
    
            // COMPAT: < 4.10 (4.9), old engine, new puzzles
            const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
            if ((isID ? objUUIDToCheck : objNameToCheck) === objName) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objName);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        // if parent referred by UUID, compare children also by UUID
                        if (isID ? (objUUIDToCheck === obj.children[j].uuid) : (objNameToCheck === obj.children[j].name)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function getObjectUUID(obj) {
        // auto-generated from a multi-material object, use parent UUID instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.uuid;
        } else {
            return obj.uuid;
        }
    }
        
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
        
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    function isMeshObject(obj) {
        if (obj.isMesh) {
            return true;
        }
    
        for (let i = 0; i < obj.children.length; i++) {
            const child = obj.children[i];
            if (child.isMesh && child.isMaterialGeneratedMesh) {
                return true;
            }
        }
    
        return false;
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    function getMaterialEditableTextures(matName, collectSameNameMats=false) {
        let mats = [];
        if (collectSameNameMats) {
            mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        } else {
            const firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
            if (firstMat !== null) {
                mats = [firstMat];
            }
        }
    
        const textures = mats.reduce((texArray, mat) => {
            let matTextures = [];
            switch (mat.type) {
                case 'MeshNodeMaterial':
                    matTextures = Object.values(mat.nodeTextures);
                    break;
    
                case 'MeshStandardMaterial':
                    matTextures = [
                        mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                        mat.bumpMap, mat.normalMap, mat.displacementMap,
                        mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
                    ];
                    break;
    
                default:
                    console.error('getMaterialEditableTextures: Unknown material type '
                            + mat.type);
                    break;
            }
    
            Array.prototype.push.apply(texArray, matTextures);
            return texArray;
        }, []);
    
        return textures.filter(elem => {
            // check Texture type exactly
            return elem && (elem.constructor === v3d.Texture
                    || elem.constructor === v3d.CompressedTexture
                    || elem.constructor === v3d.DataTexture
                    || elem.constructor === v3d.CanvasTexture
                    || elem.constructor === v3d.VideoTexture);
        });
    }
        
    function replaceMaterialEditableTexture(mat, oldTex, newTex) {
        if (v3d.MaterialUtils.replaceTexture) {
            v3d.MaterialUtils.replaceTexture(mat, oldTex, newTex);
            return;
        }
    
        // COMPAT: <4.8, had no replaceTexture() method
        switch (mat.type) {
            case 'MeshNodeMaterial':
                // NOTE: replace in node graph as well since it's possible to texture get lost
                // after updateNodeGraph()
                mat.traverseNodes(node => {
                    if (node.originData.texture === oldTex)
                        node.originData.texture = newTex;
                });
    
                for (const name in mat.nodeTextures) {
                    if (mat.nodeTextures[name] === oldTex) {
                        mat.nodeTextures[name] = newTex;
                    }
                }
                break;
    
            case 'MeshStandardMaterial':
                const texNames = ['map', 'lightMap', 'aoMap', 'emissiveMap',
                        'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap',
                        'metalnessMap', 'alphaMap', 'envMap'];
    
                texNames.forEach(name => {
                    if (mat[name] === oldTex) {
                        mat[name] = newTex;
                    }
                });
                break;
    
            default:
                console.error('replaceMaterialEditableTexture: Unsupported material type '
                        + mat.type);
                break;
        }
    
        // inherit some save params
        newTex.encoding = oldTex.encoding;
        newTex.wrapS = oldTex.wrapS;
        newTex.wrapT = oldTex.wrapT;
    }

    return {
        getObjectName, initObjectPicking, isObjectAmongObjects, retrieveObjectNames,
        transformCoordsSpace, getSceneCoordSystem, getObjectByName, getObjectUUID,
        getElements, getElement, bindListener, isMeshObject,
        isObjectWorthProcessing, transformEulerV3dToBlenderShortest, RotationInterface, getMaterialEditableTextures,
        replaceMaterialEditableTexture,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // loadFont puzzle
function loadFont(url, family) {

    if (!url || !family)
        return;

    // register in CSS
    var elemStyle = document.createElement('style');
    elemStyle.innerHTML = '@font-face { font-family: ' + family
        + '; src: url(' + url + '); }';
    document.body.appendChild(elemStyle);

    // preload font
    var elemDiv = document.createElement('div');
    elemDiv.innerHTML = 'invisible text';
    elemDiv.style.visibility = 'hidden';
    elemDiv.style.fontFamily = family;
    document.body.appendChild(elemDiv);
}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = false;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

loadFont('./Rubik-Regular.ttf', 'Rubik-Regular');

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["ender_tour"] = ender_tour;
this.procedures["warehouse_1_infographics_on"] = warehouse_1_infographics_on;
this.procedures["warehouse_2_infographics_on"] = warehouse_2_infographics_on;
this.procedures["workshop_inforgaphics_on"] = workshop_inforgaphics_on;
this.procedures["office_infographics_on"] = office_infographics_on;
this.procedures["loading_dock_infographics_on"] = loading_dock_infographics_on;
this.procedures["loading_dock_infographics_off"] = loading_dock_infographics_off;
this.procedures["warehouse_1_infographics_off"] = warehouse_1_infographics_off;
this.procedures["warehouse_2_infographics_off"] = warehouse_2_infographics_off;
this.procedures["office_infographics_off"] = office_infographics_off;
this.procedures["workshop_inforgaphics_off"] = workshop_inforgaphics_off;

var current_point, camera_moving, camera_tween, moving_to_point, panoramic_mode;

// whenHovered puzzle
PzLib.initObjectPicking(function(intersects, event) {

    const prevHovered = _pGlob.hoveredObject;
    let currHovered = '';

    // the event might happen before hover registration
    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    // search for closest hovered object

    let lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        const maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (let i = 0; i < maxIntersects; i++) {
            const obj = intersects[i].object;
            const objName = PzLib.getObjectName(obj);

            if (PzLib.isObjectAmongObjects(objName, PzLib.retrieveObjectNames(el.objSelector)) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(prevHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(currHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove');

// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}

// featureAvailable puzzle
function featureAvailable(feature) {

    const userAgent = window.navigator.userAgent;
    const platform = window.navigator.platform;
    let canvas, gl;

    switch (feature) {
    case 'MOBILE':
        return (/Android|webOS|BlackBerry/i.test(userAgent) || v3d.Detector.checkIOS());

    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'IOS':
        return v3d.Detector.checkIOS();
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1 && !v3d.Detector.checkIOS());
    case 'CHROMEOS':
        return /(CrOS)/.test(userAgent);
    case 'LINUX':
        return /Linux/.test(platform);

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return v3d.Detector.isTouchDevice();
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBAUDIO':
        return v3d.Detector.checkWebAudio();
    case 'WEBGL':
        canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl')
        return !!gl;
    case 'WEBGL2':
        canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        try {
            const woo_fun = window.parent.v3d_woo_get_product_info || window.parent.parent.v3d_woo_get_product_info;
            return !!woo_fun;
        } catch (e) {
            // blocked cross-origin access
            return false;
        }
    case 'DO_NOT_TRACK':
        if (navigator.doNotTrack == '1' || window.doNotTrack == '1')
            return true;
        else
            return false;
    default:
        return false;
    }

}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, useID, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        useID: useID,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        let isPicked = false;

        const maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (let i = 0; i < maxIntersects; i++) {
            const obj = intersects[i].object;

            const objName = PzLib.getObjectName(obj);
            const objUUID = PzLib.getObjectUUID(obj);
            const objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objUUID, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = useID ? objUUID : objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}

// setActiveCamera puzzle
function setActiveCamera(camName) {
    var camera = PzLib.getObjectByName(camName);
    if (!camera || !camera.isCamera || appInstance.getCamera() == camera)
        return;
    appInstance.setCamera(camera);
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// Describe this function...
function ender_tour() {
    setActiveCamera('tour_camera');
    changeVis(['GROUP', 'outliners'], false);
    changeVis(['GROUP', 'click_points'], true);
    changeVis(['GROUP', 'panorama_icons'], true);
    setHTMLElemStyle('display', 'none', 'enter_tour', false);
    setHTMLElemStyle('display', 'block', 'top_view', false);
    if (featureAvailable('MOBILE')) {
        workshop_inforgaphics_off();
        warehouse_1_infographics_off();
        warehouse_2_infographics_off();
        office_infographics_off();
        loading_dock_infographics_off();
    }
}

// openWebPage puzzle
function openWebPage(url, mode) {

    if (appInstance && appInstance.controls) {
        appInstance.controls.forceMouseUp();
    }

    if (mode == "NEW") {
        window.open(url);
    } else if (mode == "NO_RELOAD") {
        history.pushState('verge3d state', 'verge3d page', url);
    } else {
        var target;
        switch (mode) {
            case "SAME":
                target = "_self";
                break;
            case "TOP":
                target = "_top";
                break;
            case "PARENT":
                target = "_parent";
                break;
        }

        window.open(url, target);

    }
}

// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}

// drawLineObjectHTML and removeLineObjectHTML puzzles
function operateLineObjectHTML(objSelector, id, isParent, width, color, offset, op) {
    const elem = PzLib.getElement(id, isParent);
    if (!elem && (op == 'DRAW'))
        return;
    const objNames = PzLib.retrieveObjectNames(objSelector);
    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i];
        const obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;

        for (let j = obj.children.length - 1; j >= 0; j--) {
            const child = obj.children[j];
            if (child.isLineHTML) {
                obj.remove(child);
                child.geometry.dispose();
                child.material.dispose();

                // remove line from the cache
                _pGlob.objCache.delete(child.name);
            }
        }

        if (op == 'DRAW') {
            const line = new v3d.LineHTML(new v3d.Color(color), width);
            line.name = objName + 'Line';
            line.offset = offset;
            line.elemHTML = elem;
            obj.add(line);
        }
    }
}

// Describe this function...
function warehouse_1_infographics_on() {
    outline('warehouse_1_outliner', 'ENABLE');
    changeVis('wherehouse_1_roof', false);
    setHTMLElemStyle('display', 'block', ['receiving_warehouse', 'receiving_gates'], false);
    operateLineObjectHTML('receiving_warehouse_marker', 'receiving_warehouse', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('receiving_gates_marker', 'receiving_gates', false, 2, '#53B2FF', 0, 'DRAW');
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}

// Describe this function...
function warehouse_2_infographics_on() {
    outline('warehouse_2_outliner', 'ENABLE');
    changeVis('wherehouse_2_roof', false);
    setHTMLElemStyle('display', 'block', ['shipping_warehouse', 'backdoor_exit'], false);
    operateLineObjectHTML('shipping_warehouse_marker', 'shipping_warehouse', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('backdoor_exit_marker', 'backdoor_exit', false, 2, '#53B2FF', 0, 'DRAW');
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}

// Describe this function...
function workshop_inforgaphics_on() {
    outline('workshops_outliner', 'ENABLE');
    changeVis('workshops_roof', false);
    setHTMLElemStyle('display', 'block', ['cutting_shop', 'assembly_shop', 'paint_room', 'drying_room', 'packaging_line'], false);
    operateLineObjectHTML('cutting_shop_marker', 'cutting_shop', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('assembly_shop_marker', 'assembly_shop', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('paint_room_marker', 'paint_room', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('drying_room_marker', 'drying_room', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('packaging_line_marker', 'packaging_line', false, 2, '#53B2FF', 0, 'DRAW');
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}

// addHTMLElement puzzle
function addHTMLElement(elemType, id, mode, targetId, isParent) {
    const win = isParent ? window.parent : window;

    const elem = win.document.createElement(elemType);
    if (id !== '')
        elem.id = id;

    const targetElem = PzLib.getElement(targetId, isParent);
    if (targetElem instanceof win.Element) {
        switch (mode) {
            case 'TO':
                targetElem.appendChild(elem);
                break;
            case 'BEFORE':
                targetElem.insertAdjacentElement('beforebegin', elem);
                break;
            case 'AFTER':
                targetElem.insertAdjacentElement('afterend', elem);
                break;
        }

        _pGlob.htmlElements.add(elem);
    } else
        console.error('add HTML element puzzle: Invalid element "' + targetId + '"');
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// Describe this function...
function office_infographics_on() {
    outline('office_outliner', 'ENABLE');
    changeVis('office_roof', false);
    setHTMLElemStyle('display', 'block', ['office', 'entrance'], false);
    operateLineObjectHTML('office_marker', 'office', false, 2, '#53B2FF', 0, 'DRAW');
    operateLineObjectHTML('entrance_marker', 'entrance', false, 2, '#53B2FF', 0, 'DRAW');
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}

// Describe this function...
function loading_dock_infographics_on() {
    outline('loading_dock_outliner', 'ENABLE');
    changeVis('backyard_roof', false);
    setHTMLElemStyle('display', 'block', 'loading_dock', false);
    operateLineObjectHTML('loading_dock_marker', 'loading_dock', false, 2, '#53B2FF', 0, 'DRAW');
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}

// Describe this function...
function loading_dock_infographics_off() {
    outline('loading_dock_outliner', 'DISABLE');
    changeVis('backyard_roof', true);
    setHTMLElemStyle('display', 'none', 'loading_dock', false);
    operateLineObjectHTML('loading_dock_marker', '', false, '', '', '', 'REMOVE');
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
}

// Describe this function...
function warehouse_1_infographics_off() {
    outline('warehouse_1_outliner', 'DISABLE');
    changeVis('wherehouse_1_roof', true);
    setHTMLElemStyle('display', 'none', ['receiving_warehouse', 'receiving_gates'], false);
    operateLineObjectHTML(['receiving_warehouse_marker', 'receiving_gates_marker'], '', false, '', '', '', 'REMOVE');
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
}

// Describe this function...
function warehouse_2_infographics_off() {
    outline('warehouse_2_outliner', 'DISABLE');
    changeVis('wherehouse_2_roof', true);
    setHTMLElemStyle('display', 'none', ['shipping_warehouse', 'backdoor_exit'], false);
    operateLineObjectHTML(['shipping_warehouse_marker', 'backdoor_exit_marker'], '', false, '', '', '', 'REMOVE');
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
}

// Describe this function...
function office_infographics_off() {
    outline('office_outliner', 'DISABLE');
    changeVis('office_roof', true);
    setHTMLElemStyle('display', 'none', ['office', 'entrance'], false);
    operateLineObjectHTML(['office_marker', 'entrance_marker'], '', false, '', '', '', 'REMOVE');
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
}

// Describe this function...
function workshop_inforgaphics_off() {
    outline('workshops_outliner', 'DISABLE');
    changeVis('workshops_roof', true);
    setHTMLElemStyle('display', 'none', ['cutting_shop', 'assembly_shop', 'paint_room', 'drying_room', 'packaging_line'], false);
    operateLineObjectHTML(['cutting_shop_marker', 'assembly_shop_marker', 'paint_room_marker', 'drying_room_marker', 'packaging_line_marker'], '', false, '', '', '', 'REMOVE');
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
}

// createCSSRule puzzle
function createCSSRule(cssRule, cssRuleCont, isParent, mediaRule) {
    var style = document.createElement('style');
    style.type = 'text/css';
    if (mediaRule) {
        style.innerHTML = `@media ${mediaRule} { ${cssRule} { ${cssRuleCont} } }`;
    } else {
        style.innerHTML = `${cssRule} { ${cssRuleCont} }`;
    }

    var styles = (isParent) ? parent.document.getElementsByTagName('head')[0] :
                              document.getElementsByTagName('head')[0];
    styles.appendChild(style)
}

// bindHTMLObject puzzle
_pGlob.bindHTMLCallbackInfo = [];

function bindHTMLObject(objName, id, isParent) {
    if (!objName)
        return;
    const elem = PzLib.getElement(id, isParent);
    if (!elem)
        return;
    const obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;
    const projected = new v3d.Vector3();
    elem.style.top = 0;
    elem.style.left = 0;

    function bindHTMLUpdateCb() {
        const camera = appInstance.getCamera(true);
        camera.updateWorldMatrix(true, false);
        obj.getWorldPosition(projected).project(camera);

        const farNearCoeff = (camera.far + camera.near) / (camera.far - camera.near);
        let isBehindCamera = false;
        if (camera.isPerspectiveCamera) {
            isBehindCamera = projected.z > farNearCoeff;
        } else if (camera.isOrthographicCamera) {
            isBehindCamera = projected.z < -farNearCoeff;
        }

        if (isBehindCamera) {
            // behind the camera, just move the element out of the sight
            projected.x = projected.y = -1e5;
        } else {
            projected.x = (0.5 + projected.x / 2) * appInstance.container.offsetWidth;
            projected.y = (0.5 - projected.y / 2) * appInstance.container.offsetHeight;
        }

        elem.style.transform = "translate(" + projected.x + "px, " + projected.y + "px)";
    }

    _pGlob.bindHTMLCallbackInfo.push({
        elem: elem,
        obj: obj,
        callback: bindHTMLUpdateCb
    });

    appInstance.renderCallbacks.push(bindHTMLUpdateCb);
    if (PL.editorRenderCallbacks)
        PL.editorRenderCallbacks.push([appInstance, bindHTMLUpdateCb]);
}

// getActiveCamera puzzle
function getActiveCamera() {
    var camera = appInstance.getCamera();
    return camera.name;
}

// whenMoved puzzle
function whenMoved(objSelector, velocity, cbStart, cbMove, cbStop) {

    _pGlob.objMovementInfos = _pGlob.objMovementInfos || {};

    function savePreviousCoords(objName, obj, prevIsMoving) {
        // GC optimization
        if (_pGlob.objMovementInfos[objName]) {
            var info = _pGlob.objMovementInfos[objName];

            info.prevPosX = obj.position.x;
            info.prevPosY = obj.position.y;
            info.prevPosZ = obj.position.z;
            info.prevRotX = obj.rotation.x;
            info.prevRotY = obj.rotation.y;
            info.prevRotZ = obj.rotation.z;
            info.prevScaX = obj.scale.x;
            info.prevScaY = obj.scale.y;
            info.prevScaZ = obj.scale.z;
            info.prevIsMoving = prevIsMoving;
        } else {
            var info = {
                prevPosX: obj.position.x,
                prevPosY: obj.position.y,
                prevPosZ: obj.position.z,
                prevRotX: obj.rotation.x,
                prevRotY: obj.rotation.y,
                prevRotZ: obj.rotation.z,
                prevScaX: obj.scale.x,
                prevScaY: obj.scale.y,
                prevScaZ: obj.scale.z,
                prevIsMoving: prevIsMoving
            };
            _pGlob.objMovementInfos[objName] = info;
        }

        return info;
    }

    function checkMoving(objName, obj, elapsed) {

        var info = _pGlob.objMovementInfos[objName] ||
            savePreviousCoords(objName, obj, false);

        var delta = velocity * elapsed;

        var isMoving =
            Math.abs(obj.position.x - info.prevPosX) > delta ||
            Math.abs(obj.position.y - info.prevPosY) > delta ||
            Math.abs(obj.position.z - info.prevPosZ) > delta ||
            Math.abs(obj.rotation.x - info.prevRotX) > delta ||
            Math.abs(obj.rotation.y - info.prevRotY) > delta ||
            Math.abs(obj.rotation.z - info.prevRotZ) > delta ||
            Math.abs(obj.scale.x - info.prevScaX) > delta ||
            Math.abs(obj.scale.y - info.prevScaY) > delta ||
            Math.abs(obj.scale.z - info.prevScaZ) > delta;

        if (!info.prevIsMoving && isMoving) {
            cbStart(objName);
            savePreviousCoords(objName, obj, true);
        } else if (info.prevIsMoving && isMoving) {
            cbMove(objName);
            savePreviousCoords(objName, obj, true);
        } else if (info.prevIsMoving && !isMoving) {
            cbStop(objName);
            savePreviousCoords(objName, obj, false);
        } else {
            savePreviousCoords(objName, obj, false);
        }
    }

    function addToRender(objSelector) {

        function renderCb(elapsed, timeline) {

            var objNames = PzLib.retrieveObjectNames(objSelector);

            for (var i = 0; i < objNames.length; i++) {
                var objName = objNames[i];

                var obj = PzLib.getObjectByName(objName);
                if (!obj)
                    return;

                checkMoving(objName, obj, elapsed);
            }
        }

        appInstance.renderCallbacks.push(renderCb);
        if (PL.editorRenderCallbacks)
            PL.editorRenderCallbacks.push([appInstance, renderCb]);

    }

    addToRender(objSelector);

}

// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == 'function') {
        appInstance.renderCallbacks.push(callback);
        if (PL.editorRenderCallbacks)
            PL.editorRenderCallbacks.push([appInstance, callback]);
    }
}

// snapToObject puzzle
function snapToObject(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;
    var obj = PzLib.getObjectByName(objName);
    var targetObj = PzLib.getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;
    obj.copyTransform(targetObj);
    obj.updateWorldMatrix(false, true);
}

function getObjectsFromCollect(obj, type, nameFilterType, nameFilter, useID, out) {
    if (!PzLib.isObjectWorthProcessing(obj)) {
        return;
    }

    let doCollect = true;

    if (nameFilter) {
        switch (nameFilterType) {
        case 'NAME_EQUAL':
            if (obj.name != nameFilter)
                doCollect = false;
            break;
        case 'NAME_START':
            if (!obj.name.startsWith(nameFilter))
                doCollect = false;
            break;
        case 'NAME_END':
            if (!obj.name.endsWith(nameFilter))
                doCollect = false;
            break;
        case 'NAME_INCLUDE':
            if (!obj.name.includes(nameFilter))
                doCollect = false;
            break;
        }
    }

    if (doCollect) {
        const nameOrID = useID ? obj.uuid : obj.name;

        switch (type) {
        case 'ALL':
        case 'FIRST':
            if (out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'ANNOTATION':
            if (obj.isAnnotation && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'BONE':
            if (obj.isBone && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'CAMERA':
            if (obj.isCamera && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'EMPTY':
            if (!obj.isAnnotationControl && !obj.isBone && !obj.isCamera &&
                    !obj.isGroup && !obj.isLine && !obj.isLOD && !obj.isLight &&
                    !PzLib.isMeshObject(obj) && !obj.isPoints && !obj.isScene &&
                    !obj.isSprite && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'LIGHT':
            if (obj.isLight && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        case 'MESH':
            if (PzLib.isMeshObject(obj) && out.indexOf(nameOrID) < 0)
                out.push(nameOrID);
            break;
        default:
            console.error('get objects from puzzle: Unknown object type: ' + type);
            break;
        }
    }

    for (let i = 0; i < obj.children.length; i++) {
        const child = obj.children[i];
        getObjectsFromCollect(child, type, nameFilterType, nameFilter, useID, out);
    }
}

// getObjectsFrom puzzle
function getObjectsFrom(objSelector, type, nameFilterType, nameFilter, useID) {
    const out = [];

    const objNames = PzLib.retrieveObjectNames(objSelector);

    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i]
        if (!objName)
            continue;

        const obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;

        getObjectsFromCollect(obj, type, nameFilterType, nameFilter, useID, out);
    }

    return (type == 'FIRST') ? out[0] : out;
}

// convertToNumber puzzle
function toNumber(text) {
    var num = Number(text);
    if (isNaN(num))
        num = 0;
    return num;
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset) {
    const x = vector[0];
    const y = vector[1];
    const z = vector[2];

    if (isNaN(x) || isNaN(y) || isNaN(z)) {
        console.error('set transform puzzle: Invalid transform');
        return;
    }

    const objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    const inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''), Number(z !== ''));
    const coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    const coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (let i = 0; i < objNames.length; i++) {

        const objName = objNames[i];
        if (!objName) continue;

        const obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            const euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            const rotUI = PzLib.RotationInterface.initObject(obj);
            const euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);
        }

        obj.updateWorldMatrix(false, true);
    }

}

// replaceTexture puzzle
function replaceTexture(matName, texName, texUrlOrElem, noSharing, doCb) {

    const textures = PzLib.getMaterialEditableTextures(matName, true).filter(function(elem) {
        return elem.name == texName;
    });

    if (!textures.length)
        return;

    const mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function(response) {
           processImageUrl(response);
        }, function(error) {});

    } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

    /**
     * NOTE: not checking for the PzLib.MediaHTML5 constructor, because otherwise this
     * puzzle would always provide the code that's not needed most of the time
     */
    } else if (texUrlOrElem instanceof Object && texUrlOrElem.source
            instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem.source);

    } else if (texUrlOrElem instanceof HTMLCanvasElement) {

        processCanvas(texUrlOrElem);

    } else {

        return;

    }

    function processImageUrl(url) {

        const isHDR = (url.search(/\.hdr$/) > 0);
        const isComp = (url.search(/\.ktx2/) > 0);

        let isCompOld = false;
        let isVideoOld = false;
        textures.forEach(function(elem) {
            if (elem.isCompressedTexture)
                isCompOld = true;
            if (elem.isVideoTexture)
                isVideoOld = true;
        });

        let loader;

        if (!isHDR && !isComp && !isCompOld && !isVideoOld) {
            loader = new v3d.ImageLoader();
            loader.setCrossOrigin('Anonymous');
        } else if (isComp) {
            loader = appInstance.loader.ktx2Loader;
            loader.setCrossOrigin('Anonymous');
        } else if (isCompOld || isVideoOld) {
            loader = new v3d.TextureLoader();
            loader.setCrossOrigin('Anonymous');
        } else {
            loader = new v3d.FileLoader();
            loader.setResponseType('arraybuffer');
        }

        loader.load(url, function(loadedData) {

            textures.forEach(function(oldTex) {
                oldTex.dispose();

                let newTex;

                if (!isHDR && !isComp && !isCompOld && !isVideoOld) {

                    if (noSharing) {
                        newTex = oldTex.clone();
                        mats.forEach(function(mat) {
                            PzLib.replaceMaterialEditableTexture(mat, oldTex, newTex);
                            mat.needsUpdate = true;
                        });
                    } else {
                        newTex = oldTex;
                    }

                    newTex.source = new v3d.Source(loadedData);

                } else if (isComp || isCompOld || isVideoOld) {

                    newTex = loadedData;

                    mats.forEach(function(mat) {
                        newTex.flipY = false;
                        newTex.name = texName;
                        PzLib.replaceMaterialEditableTexture(mat, oldTex, newTex);
                        mat.needsUpdate = true;
                    });

                } else {
                    // parse loaded HDR buffer
                    const rgbeLoader = new v3d.RGBELoader();
                    const texData = rgbeLoader.parse(loadedData);

                    if (noSharing) {
                        newTex = oldTex.clone();
                        mats.forEach(function(mat) {
                            PzLib.replaceMaterialEditableTexture(mat, oldTex, newTex);
                            mat.needsUpdate = true;
                        });
                    } else {
                        newTex = oldTex;
                    }

                    newTex.source = new v3d.Source({
                        data: texData.data,
                        width: texData.width,
                        height: texData.height
                    });

                    newTex.magFilter = v3d.LinearFilter;
                    newTex.minFilter = v3d.LinearFilter;
                    newTex.generateMipmaps = false;
                    newTex.isDataTexture = true;
                }

                // update world material if it is using this texture
                if (appInstance.scene !== null && appInstance.scene.worldMaterial !== null) {
                    var wMat = appInstance.scene.worldMaterial;
                    for (let texName in wMat.nodeTextures) {
                        if (wMat.nodeTextures[texName] == newTex) {
                            appInstance.updateEnvironment(wMat);
                        }
                    }
                }
            });

            // exec once
            doCb();

        });
    }

    function processVideo(elem) {
        const videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        let videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                PzLib.replaceMaterialEditableTexture(mat, tex, videoTex);
            });

            mat.needsUpdate = true;
            // HACK: to assign new encoding in nodes, workaround for https://crbug.com/1256340
            if (mat.isMeshNodeMaterial) {
                if (v3d.engineVersionCmp('4.9.0', v3d.REVISION) >= 0) {
                    mat.updateNodeGraph(true);
                } else {
                    // COMPAT: <4.9.0, new puzzles, old engine
                    // HACK: preserve links to uniform arrays which got replaced in updateNodeGraph()
                    const nodeRGBArrSave = mat.nodeRGBArr;
                    const nodeValueSave = mat.nodeValue;
                    mat.updateNodeGraph();
                    mat.nodeRGBArr = nodeRGBArrSave;
                    mat.nodeValue = nodeValueSave;
                }
            }

            videoAssigned = true;
        });

        if (videoAssigned) {
            if (elem.readyState < 1) {
                PzLib.bindListener(elem, 'loadedmetadata', doCb);
            } else {
                doCb();
            }
        }

    }

    function processCanvas(elem) {
        const canvasTex = new v3d.CanvasTexture(elem);
        canvasTex.flipY = false;
        canvasTex.name = texName;

        let canvasAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                PzLib.replaceMaterialEditableTexture(mat, tex, canvasTex);
            });

            mat.needsUpdate = true;
            canvasAssigned = true;
        });

        if (canvasAssigned) {

            if (PL) {
                PL.canvasTextures = PL.canvasTextures || {};
                PL.canvasTextures[canvasTex.image.id] = canvasTex;
            }

            doCb();
        }

    }
}

// getHTMLElemAttribute puzzle
function getHTMLElemAttribute(attr, id, isParent) {
    var elem = PzLib.getElement(id, isParent);
    return elem ? elem[attr]: '';
}

// setInterval puzzle
function registerInterval(timeout, callback) {
    var timerId = window.setInterval(function() { callback(timerId) }, 1000 * timeout);
}


registerOnHover('workshops_outliner', false, function(event) {
    workshop_inforgaphics_on();
}, function(event) {
    workshop_inforgaphics_off();
});
registerOnClick('workshops_outliner', false, false, [0,1,2], false, function(event) {
    if (featureAvailable('MOBILE')) {
        workshop_inforgaphics_on();
        warehouse_1_infographics_off();
        warehouse_2_infographics_off();
        office_infographics_off();
        loading_dock_infographics_off();
    }
    tweenCamera('', 'workshops_outliner', 1, function() {}, 0);
}, function(event) {});

if (featureAvailable('RETINA')) {
    setScreenScale(1.5);
}

registerOnHover('warehouse_1_outliner', false, function(event) {
    warehouse_1_infographics_on();
}, function(event) {
    warehouse_1_infographics_off();
});
registerOnClick('warehouse_1_outliner', false, false, [0,1,2], false, function(event) {
    if (featureAvailable('MOBILE')) {
        warehouse_1_infographics_on();
        workshop_inforgaphics_off();
        warehouse_2_infographics_off();
        office_infographics_off();
        loading_dock_infographics_off();
    }
    tweenCamera('', 'warehouse_1_outliner', 1, function() {}, 0);
}, function(event) {});

registerOnHover('warehouse_2_outliner', false, function(event) {
    warehouse_2_infographics_on();
}, function(event) {
    warehouse_2_infographics_off();
});
registerOnClick('warehouse_2_outliner', false, false, [0,1,2], false, function(event) {
    if (featureAvailable('MOBILE')) {
        warehouse_2_infographics_on();
        workshop_inforgaphics_off();
        warehouse_1_infographics_off();
        office_infographics_off();
        loading_dock_infographics_off();
    }
    tweenCamera('', 'warehouse_2_outliner', 1, function() {}, 0);
}, function(event) {});

registerOnHover('office_outliner', false, function(event) {
    office_infographics_on();
}, function(event) {
    office_infographics_off();
});
registerOnClick('office_outliner', false, false, [0,1,2], false, function(event) {
    if (featureAvailable('MOBILE')) {
        office_infographics_on();
        workshop_inforgaphics_off();
        warehouse_1_infographics_off();
        warehouse_2_infographics_off();
        loading_dock_infographics_off();
    }
    tweenCamera('', 'office_outliner', 1, function() {}, 0);
}, function(event) {});

registerOnHover('loading_dock_outliner', false, function(event) {
    loading_dock_infographics_on();
}, function(event) {
    loading_dock_infographics_off();
});
registerOnClick('loading_dock_outliner', false, false, [0,1,2], false, function(event) {
    if (featureAvailable('MOBILE')) {
        loading_dock_infographics_on();
        workshop_inforgaphics_off();
        warehouse_1_infographics_off();
        warehouse_2_infographics_off();
        office_infographics_off();
    }
    tweenCamera('', 'loading_dock_outliner', 1, function() {}, 0);
}, function(event) {});

registerOnClick('banner', false, false, [0,1,2], false, function(event) {
    openWebPage('https://www.soft8soft.com/', 'NEW');
}, function(event) {});
registerOnHover('banner', false, function(event) {
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}, function(event) {
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
});

addHTMLElement('div', 'enter_tour', 'TO', ['CONTAINER'], false);
setHTMLElemAttribute('style', "position: absolute; background: linear-gradient(45deg, rgba(254,148,24,1) 0%, rgba(255,171,73,1) 100%); width: 240px; height: 30px; cursor: pointer; bottom: 20px; left: 50%; margin-left: -110px; text-align: center; font-size: 22px; color: white; font-family: Rubik-Regular; border-radius: 4px; box-shadow: 0px 0px 4px #00000087; user-select: none;", 'enter_tour', false);
setHTMLElemAttribute('innerHTML', 'Start Factory Tour', 'enter_tour', false);
eventHTMLElem('click', 'enter_tour', false, function(event) {
    ender_tour();
});
registerOnHover('current_point_marker', true, function(event) {
    setHTMLElemStyle('cursor', 'pointer', ['CONTAINER'], false);
}, function(event) {
    setHTMLElemStyle('cursor', 'default', ['CONTAINER'], false);
});
registerOnClick('current_point_marker', true, false, [0,1,2], false, function(event) {
    ender_tour();
}, function(event) {});

createCSSRule('.infographics', "position: absolute; background-color: #53B2FF; width: 170px; margin-left: -85px; height: 20px; text-align: center; font-size: 16px; color: white; font-family: Rubik-Regular; border-radius: 4px; user-select: none;", false, '');

addHTMLElement('div', 'cutting_shop', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'assembly_shop', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'paint_room', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'drying_room', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'packaging_line', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'receiving_warehouse', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'receiving_gates', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'office', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'entrance', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'shipping_warehouse', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'backdoor_exit', 'TO', ['CONTAINER'], false);
addHTMLElement('div', 'loading_dock', 'TO', ['CONTAINER'], false);
setHTMLElemAttribute('className', 'infographics', ['cutting_shop', 'assembly_shop', 'paint_room', 'drying_room', 'packaging_line', 'receiving_warehouse', 'receiving_gates', 'office', 'entrance', 'shipping_warehouse', 'backdoor_exit', 'loading_dock'], false);
setHTMLElemStyle('display', 'none', ['cutting_shop', 'assembly_shop', 'paint_room', 'drying_room', 'packaging_line', 'receiving_warehouse', 'receiving_gates', 'office', 'entrance', 'shipping_warehouse', 'backdoor_exit', 'loading_dock'], false);

setHTMLElemAttribute('innerHTML', 'Cutting Shop', 'cutting_shop', false);
bindHTMLObject('cutting_shop_sign', 'cutting_shop', false);
setHTMLElemAttribute('innerHTML', 'Assembly Shop', 'assembly_shop', false);
bindHTMLObject('assembly_shop_sign', 'assembly_shop', false);
setHTMLElemAttribute('innerHTML', 'Paint Room', 'paint_room', false);
bindHTMLObject('paint_room_sign', 'paint_room', false);
setHTMLElemAttribute('innerHTML', 'Drying Room', 'drying_room', false);
bindHTMLObject('drying_room_sign', 'drying_room', false);
setHTMLElemAttribute('innerHTML', 'Packaging Line', 'packaging_line', false);
bindHTMLObject('packaging_line_sign', 'packaging_line', false);
setHTMLElemAttribute('innerHTML', 'Receiving Warehouse', 'receiving_warehouse', false);
bindHTMLObject('receiving_warehouse_sign', 'receiving_warehouse', false);
setHTMLElemAttribute('innerHTML', 'Receiving Gates', 'receiving_gates', false);
bindHTMLObject('receiving_gates_sign', 'receiving_gates', false);
setHTMLElemAttribute('innerHTML', 'Office', 'office', false);
bindHTMLObject('office_sign', 'office', false);
setHTMLElemAttribute('innerHTML', 'Main Entrance', 'entrance', false);
bindHTMLObject('entrance_sign', 'entrance', false);
setHTMLElemAttribute('innerHTML', 'Shipping Warehouse', 'shipping_warehouse', false);
bindHTMLObject('shipping_warehouse_sign', 'shipping_warehouse', false);
setHTMLElemAttribute('innerHTML', 'Backdoor Exit', 'backdoor_exit', false);
bindHTMLObject('backdoor_exit_sign', 'backdoor_exit', false);
setHTMLElemAttribute('innerHTML', 'Loading Dock', 'loading_dock', false);
bindHTMLObject('loading_dock_sign', 'loading_dock', false);

registerEveryFrame(function() {
    whenMoved(getActiveCamera(), 0.2, function() {
        camera_moving = true;
    }, function() {}, function() {
        camera_moving = false;
    });
});

current_point = 0;
camera_moving = false;
camera_tween = false;

addHTMLElement('div', 'top_view', 'TO', ['CONTAINER'], false);
setHTMLElemAttribute('style', "position: absolute; background-image: url(\'media/top_view.svg\'); background-size: 100%; width: 50px; height: 50px; cursor: pointer; top: 5px; left: 5px; user-select: none;", 'top_view', false);
setHTMLElemStyle('display', 'none', 'top_view', false);
eventHTMLElem('click', 'top_view', false, function(event) {
    setActiveCamera('top_view_camera');
    changeVis(['GROUP', 'click_points'], false);
    changeVis(['GROUP', 'panorama_icons'], false);
    changeVis(['GROUP', 'outliners'], true);
    setHTMLElemAttribute('innerHTML', 'Resume Factory Tour', 'enter_tour', false);
    setHTMLElemStyle('display', 'block', 'enter_tour', false);
    setHTMLElemStyle('display', 'none', 'top_view', false);
    snapToObject('current_point_marker', 'click_point_' + String(current_point));
    if (featureAvailable('MOBILE')) {
        tweenCamera('', 'workshops_outliner', 0.01, function() {}, 0);
    }
});

registerOnClick(getObjectsFrom(['GROUP', 'click_points'], 'ALL', 'null', undefined, false), false, false, [0,1,2], false, function(event) {
    if (camera_moving == false && camera_tween == false) {
        moving_to_point = _pGlob.pickedObject;
        if (current_point < toNumber(moving_to_point.slice(12, moving_to_point.length))) {
            camera_tween = true;
            tweenCamera('camera_point_' + String(moving_to_point.slice(12, moving_to_point.length)), 'camera_point_' + String(toNumber(moving_to_point.slice(12, moving_to_point.length)) + 1), 1.5, function() {
                camera_tween = false;
                current_point = toNumber(moving_to_point.slice(12, moving_to_point.length));
            }, 0);
        } else if (current_point > toNumber(moving_to_point.slice(12, moving_to_point.length))) {
            camera_tween = true;
            tweenCamera('camera_point_' + String(moving_to_point.slice(12, moving_to_point.length)), 'camera_point_' + String(toNumber(moving_to_point.slice(12, moving_to_point.length)) - 1), 1.5, function() {
                camera_tween = false;
                current_point = toNumber(moving_to_point.slice(12, moving_to_point.length));
            }, 0);
        }
    }
}, function(event) {});

registerOnClick('office_panorama_icon', false, false, [0,1,2], false, function(event) {
    replaceTexture('panorama_room', 'panorama_image', 'panoramas/office.webp', false, function() {
        setObjTransform('panorama_camera', false, 'rotation', [0, 0, -90], false);
        setActiveCamera('panorama_camera');
        panoramic_mode = true;
        setHTMLElemStyle('display', 'none', 'top_view', false);
        changeVis('office_exit_icon', true);
    });
}, function(event) {});
registerOnClick('office_exit_icon', false, false, [0,1,2], false, function(event) {
    setHTMLElemStyle('display', 'block', 'top_view', false);
    changeVis('office_exit_icon', false);
    setActiveCamera('tour_camera');
}, function(event) {});

registerOnClick('cutting_shop_icon', false, false, [0,1,2], false, function(event) {
    replaceTexture('panorama_room', 'panorama_image', 'panoramas/cutting_shop.webp', false, function() {
        setObjTransform('panorama_camera', false, 'rotation', [0, 0, -90], false);
        setActiveCamera('panorama_camera');
        panoramic_mode = true;
    });
    changeVis('cutting_shop_exit_icon', true);
    setHTMLElemStyle('display', 'none', 'top_view', false);
}, function(event) {});
registerOnClick('cutting_shop_exit_icon', false, false, [0,1,2], false, function(event) {
    setHTMLElemStyle('display', 'block', 'top_view', false);
    changeVis('cutting_shop_exit_icon', false);
    setActiveCamera('tour_camera');
}, function(event) {});

registerOnClick('shipping_warehouse_icon', false, false, [0,1,2], false, function(event) {
    replaceTexture('panorama_room', 'panorama_image', 'panoramas/shipping_warehouse.webp', false, function() {
        setObjTransform('panorama_camera', false, 'rotation', [0, 0, 0], false);
        setActiveCamera('panorama_camera');
        panoramic_mode = true;
        setHTMLElemStyle('display', 'none', 'top_view', false);
        changeVis('shipping_and_painting_exit_icon', true);
    });
}, function(event) {});
registerOnClick('shipping_and_painting_exit_icon', false, false, [0,1,2], false, function(event) {
    setHTMLElemStyle('display', 'block', 'top_view', false);
    changeVis('shipping_and_painting_exit_icon', false);
    setActiveCamera('tour_camera');
}, function(event) {});

registerOnClick('paint_room_icon', false, false, [0,1,2], false, function(event) {
    replaceTexture('panorama_room', 'panorama_image', 'panoramas/paint_room.webp', false, function() {
        setObjTransform('panorama_camera', false, 'rotation', [0, 0, -90], false);
        setActiveCamera('panorama_camera');
        panoramic_mode = true;
        setHTMLElemStyle('display', 'none', 'top_view', false);
        changeVis('shipping_and_painting_exit_icon', true);
    });
}, function(event) {});
registerOnClick('shipping_and_painting_exit_icon', false, false, [0,1,2], false, function(event) {
    setHTMLElemStyle('display', 'block', 'top_view', false);
    changeVis('shipping_and_painting_exit_icon', false);
    setActiveCamera('tour_camera');
}, function(event) {});

registerOnClick('assembly_shop_icon', false, false, [0,1,2], false, function(event) {
    replaceTexture('panorama_room', 'panorama_image', 'panoramas/assembly_shop.webp', false, function() {
        setObjTransform('panorama_camera', false, 'rotation', [0, 0, -90], false);
        setActiveCamera('panorama_camera');
        panoramic_mode = true;
        setHTMLElemStyle('display', 'none', 'top_view', false);
        changeVis('assembly_shop_exit_icon', true);
    });
}, function(event) {});
registerOnClick('assembly_shop_exit_icon', false, false, [0,1,2], false, function(event) {
    setHTMLElemStyle('display', 'block', 'top_view', false);
    changeVis('assembly_shop_exit_icon', false);
    setActiveCamera('tour_camera');
}, function(event) {});

addHTMLElement('div', 'rotate_your_phone', 'TO', ['CONTAINER'], false);
setHTMLElemAttribute('style', "position: absolute; background-image: url(\'media/rotate_your_phone.svg\'); background-size: 100%; width: 300px; height: 200px; left: 50%; margin-left: -150px; top: 50%; margin-top: -100px; display: none;", 'rotate_your_phone', false);

registerInterval(0.1, function() {
    if (getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / getHTMLElemAttribute('innerHeight', ['WINDOW'], false) > 1) {
        setHTMLElemStyle('display', 'none', 'rotate_your_phone', false);
    } else {
        setHTMLElemStyle('display', 'block', 'rotate_your_phone', false);
    }
});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
